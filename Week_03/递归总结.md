# 递归
+ 本质上是一个循环（函数的汇编代码就是一段可循环的程序片断），是一个用函数体进行的循环
+ 递归模板如下：
~~~c++
Recursion(...) {
	if (满足终止条件) {
		...
		return;
	}
	//处理当前层的逻辑
	process(...)
	
	//进入到下一层
	Recursion(...)
	
	//恢复原来状态（可选）
}
~~~
+题目：
	1. 70.爬楼梯
	2. 17.电话号码的字母组合
	3. 22.括号生成
	4. 236.二叉树的最近公共祖先

# 回溯
+ 回溯是一种比较特殊的递归，回溯有三个主要元素：
	1. 答案集合：一般而言，涉及到回溯的题目一般都会要求找出所有满足要求的答案，这些答案就组成了一个答案集合。
	2. 候选答案：一些由候选元素组成的答案，这些答案不一定满足题目要求，但满足要求的候选答案则要添加到答案集合中。
	3. 候选元素：候选元素是组成候选答案的元素；在回溯过程中，一般会涉及到候选元素的选择与撤销。
+ 另外还有三个要点，利用回溯解题时，需要辨识出三个主要元素以及这三个要点：
	1. 候选答案加入答案集合的时机
	2. 递归树终止的条件
	3. 候选元素可被选中的条件。一般而言，候选元素可否被选中要从回溯树的两个维度去判断：
		+ 横向：同一轮选择上有限制条件，一般是元素有重复的情况（47. 全排列 II、90. 子集 II）
		+ 纵向：以往的选择对本轮选择有限制影响，如：用过的元素不能再用等（子集问题、全排列问题以及组合都是）
+ 回溯模板
~~~c++
void Traceback(answer_set, answer, elements, (其他辅助性的变量，比如哈希表、层数引索，起始引索等)) {
	if (候选答案加入答案集合的时机) {
		answer_set.push(answer);
	}
	for (对于候选元素中的每个元素) {
		if (满足候选元素可被选中的条件) {
			将当前候选元素加入answer
			（辅助变量也相应处理）
			Traceback(...);//进入回溯树的下一层
			将当前候选元素从answer中移除
			（辅助变量也相应撤销变动）
		}
	}
}
~~~
+ 回溯主要用于以下三大类问题：
	1. 组合：从给定的候选元素中选取出一定数量的元素，组成一个答案，求这些答案的集合（77.组合）
	2. 子集：从给定的候选元素中取出不定数量的元素，组成一个答案，求这些答案的集合(78.子集、90. 子集 II)；
	3. 排列：从给定的候选元素中，对这些元素进行排列，求出所有可能的排列形式（46. 全排列、47. 全排列 II）；
+ 对于有重复元素的回溯问题，常用标记数组法进行剪枝：
>if(index >= 1 && nums[index] == nums[index - 1] && ！flag[index-1]) continue；
flag是标记数组，flag[i]表示nums[i]是否已经被选入候选答案中；换句话：即表示候选元素列表中，位置为i的元素是否已经被选入候选答案中
解释：
（1）这种方法用于候选元素列表有重复元素、且同层不能使用已使用过的元素的情况；要配合排序使用
（2）候选元素列表排序之后，重复元素必定相邻，index >= 1 && nums[index] == nums[index - 1]能筛选出选择重复元素的情况；
但调用重复元素有两种情况：
1.纵向方向上：比如90.子集II，在纵向方向上是给候选答案加入一个元素的（[1,2]可以重复加入2而成为[1,2,2]）,此时可以选择重复元素；
2.横向方向上：同样以90.子集II为例，假设此时候选答案为[],候选元素为1,2,2,那么选了一次2之后，候选列表中还有一个2，在for循环中仍会重复出现2；
但在已选择了一个2的情况下仍选择2作为这层的被选元素，那么这一次选择所递归出的递归树将与前一次选择2所递归出的递归数相同，导致出现重复解，因此在同一层中，要避免多次选择重复元素。
（3）我们可以用flag[index-1]来判断出第2种情况：flag[index-1] == true时，说明nums[index-1]已经被选入候选答案中且没有被撤销选择，此时是在纵向方向上出现重复元素，为情况（1）;当flag[index-1] == false时，意味着
nums[index-1]被撤销选择，为横向方向上出现重复元素，为情况（2）

+ 题目：
	1. 78.子集
	2. 90. 子集 II
	3. 46. 全排列
	4. 47. 全排列 II
	5. 77.组合

# 分治
+ 分治一般用于可重复地拆分成更小规模的问题
+ 分治模板：
~~~c++
divide_conquer(...):
	if (如果当前问题已达到最小规模) {
		直接返回当前问题的解
	}
	
	//准备数据
	data = prepare_data(...);
	
	//拆分问题
	result_1 = divide_conquer(...);
	result_2 = divide_conquer(...);
	...
	
	//合并子问题结果
	result = merge(result_1, result_2, ...);
	return result;
~~~
+ 题目：
	1. 50. Pow(x, n)
	2. 169.多数元素
	3. 105. 从前序与中序遍历序列构造二叉树